// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define PI 3.14159265359
#define PI2 6.28318530718

Texture2D<float4> source;
RWTexture2D<float4> outputrt;
float time;
float4 axisColor;
float4 sweepColor;

float getDelta(float x){
    return (sin(x)+1.0)/2.0;
}

float sweep(float2 position, float2 center, float radius, float lineWidth, float edgeWidth) {
    float2 direction = position - center;
    float theta = time + 6.3;
    float2 circlePoint = float2(cos(theta), -sin(theta)) * radius;
    float projection = clamp(dot(direction, circlePoint) / dot(circlePoint, circlePoint), 0.0, 1.0);
    float lineDistance = length(direction - circlePoint * projection);

    float gradient = 0.0;
    const float maxGradientAngle = PI * 0.5;

    if (length(direction) < radius) {
        float angle = fmod(theta + atan2(direction.y, direction.x), PI2);
        gradient = clamp(maxGradientAngle - angle, 0.0, maxGradientAngle) / maxGradientAngle * 0.5;
    }

    return gradient + 1.0 - smoothstep(lineWidth, lineWidth + edgeWidth, lineDistance);
}

float circle(float2 position, float2 center, float radius, float lineWidth, float edgeWidth){
    position -= center;
    float len = length(position);
    //Change true to false to soften the edge
    float result = smoothstep(radius - lineWidth / 2.0 - edgeWidth, radius - lineWidth / 2.0, len) - smoothstep(radius + lineWidth / 2.0, radius + lineWidth / 2.0 + edgeWidth, len);

    return result;
}

// float onLine(float x, float y, float line_width, float edge_width){
//     return smoothstep(x-line_width/2.0-edge_width, x-line_width/2.0, y) - smoothstep(x+line_width/2.0, x+line_width/2.0+edge_width, y);
//     // return smoothstep(x-line_width/2.0-edge_width, x-line_width/2.0, y);
// }

float onLine(float position, float center, float lineWidth, float edgeWidth) {
    float halfWidth = lineWidth / 2.0;
    float edge0 = center - halfWidth - edgeWidth;
    float edge1 = center - halfWidth;
    float edge2 = center + halfWidth;
    float edge3 = center + halfWidth + edgeWidth;
    // return smoothstep(edge0, edge1, position);
    // return smoothstep(edge2, edge3, position);
    return smoothstep(edge0, edge1, position) - smoothstep(edge2, edge3, position);
}

float polygon(float2 pt, float2 center, float radius, int sides, float rotate, float edge_thickness){
    pt -= center;

    // Angle and radius from the current pixel 
    float theta = atan2(pt.y, pt.x) + rotate;
    float rad = PI2/float(sides);

    // Shaping function that modulate the distance    
    float d = cos(floor(0.5 + theta/rad)*rad-theta)*length(pt);

    return 1.0 - smoothstep(radius, radius + edge_thickness, d);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float3 white = 1;
    
    float2 uv = (float2)id.xy;
    float2 center = 0.5;
    float aspectRatio = (float)source.Length.x/(float)source.Length.y;

    if (aspectRatio>1){
        uv /= (float)source.Length.y;
        center.x *= aspectRatio; 
    }else{
        uv /= (float)source.Length.x;
        center.y /= aspectRatio;
    }

    float3 color = float3(0.0f,0.0f,0.0f);
    color += onLine(uv.y, center.y, 0.002, 0.001) * axisColor.rgb;//xAxis
    color += onLine(uv.x, center.x, 0.002, 0.001) * axisColor.rgb;//yAxis
    color += circle(uv, center, 0.2f, 0.002, 0.001) * axisColor.rgb;
    color += circle(uv, center, 0.3f, 0.002, 0.001) * axisColor.rgb;
    color += circle(uv, center, 0.4f, 0.002, 0.001) * axisColor.rgb;
    color += sweep(uv, center, 0.45f, 0.003, 0.001) * sweepColor.rgb;


    //TO DO: Add code here

    float alpha = saturate(color.r + color.g + color.b);
    float3 finalColor = lerp(source[id.xy].rgb, color, alpha);

    outputrt[id.xy] = float4(finalColor, 1.0);
}