// Each #kernel tells which function to compile; you can have many kernels
#define THREADGROUPSIZE 128 
#pragma kernel BendGrass

#include "noiseSimplex.cginc"

struct GrassBlade
{
    float3 position;
    float height_offset;
    float width_offset;
    float dir;
    float fade;
    float4 quaternion;
    float padding;
};
RWStructuredBuffer<GrassBlade> bladesBuffer;
float time;
float maxBend;
float4 wind;
float4 tramplePos;
float trampleRadius;

float4 MapVector(float3 v1, float3 v2){
    v1 = normalize(v1);
    v2 = normalize(v2);
    float3 v = v1+v2;
    v = normalize(v);
    float4 q = 0;
    q.w = dot(v, v2);
    q.xyz = cross(v, v2);
    return q;
}
float4 quatMultiply(float4 q1, float4 q2) {
    // q1 = a + bi + cj + dk
    // q2 = x + yi + zj + wk
    // Result = q1 * q2
    return float4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y, // X component
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x, // Y component
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w, // Z component
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z  // W (real) component
    );
}
[numthreads(THREADGROUPSIZE,1,1)]
void BendGrass (uint3 id : SV_DispatchThreadID)
{
    GrassBlade blade = bladesBuffer[id.x];

    float3 relativePosition = blade.position - tramplePos.xyz;
    float dist = length(relativePosition);

    float4 qt;
    
    if (dist<trampleRadius){
        float eff = ((trampleRadius - dist)/trampleRadius) * 0.8;
        qt = MapVector(float3(0,1,0), float3(relativePosition.x*eff,1,relativePosition.y*eff));
    }else{
        qt = MapVector(float3(0,1,0),float3(0,1,0));
    }
    
    float2 offset = (blade.position.xz + wind.xy * time * wind.z) * wind.w;
    float noise = perlin(offset.x, offset.y) * 2 - 1;
    noise *= maxBend;
    float4 q1 = MapVector(float3(0,1,0), (float3(wind.x * noise,1,wind.y*noise)));
    float faceTheta = blade.dir * 3.1415f / 180.0f;
    float4 q2 = MapVector(float3(1,0,0),float3(cos(faceTheta),0,sin(faceTheta)));
    blade.quaternion = quatMultiply(qt,quatMultiply(q2,q1));
    bladesBuffer[id.x] = blade;
}
